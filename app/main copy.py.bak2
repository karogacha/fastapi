from fastapi import FastAPI, Response, status, HTTPException
from fastapi.params import Body
from pydantic import BaseModel
from typing import Optional
from random import randrange
import time

app = FastAPI()

class Post(BaseModel):
    title: str
    content: str
    published: bool = True
    rating: Optional[int] = None

"""
Connects to a SQL database using pyodbc
"""
import pyodbc

SERVER = '.\SQLEXPRESS'
DATABASE = 'fastapi'
USERNAME = 'sa'
PASSWORD = 'fgaror'
# From https://learn.microsoft.com/en-us/sql/connect/python/pyodbc/step-3-proof-of-concept-connecting-to-sql-using-pyodbc?view=sql-server-ver16
# connectionString = f'DRIVER={{ODBC Driver 18 for SQL Server}};SERVER={SERVER};DATABASE={DATABASE};UID={USERNAME};PWD={PASSWORD}'
# Uses a different driver, but this one works fine for my database
connectionString = f'DRIVER={{SQL Server Native Client 11.0}};SERVER={SERVER};DATABASE={DATABASE};UID={USERNAME};PWD={PASSWORD}'

while True:
    try:
        conn = pyodbc.connect(connectionString)
        cursor = conn.cursor()
        print("Database connection was successful.")
        break
    except Exception as error:
        print("Connecting to database failed.")
        print("Error:", error)
        time.sleep(3)

my_posts = [{"title": "Mi primer post", "content": "This is the detail of how to make pizza", "id": 1},
            {"title": "Favorite foods", "content": "Pizza, chocolate, and fried chicken", "id": 2}]

def find_post(id):
    return [p for p in my_posts if p['id']==id]

@app.get("/")
async def root():
    return {"message": "Welcome to my API"}

@app.get("/posts")
def get_posts():
    # Retrieve the data from the SQL Server
    SQL_QUERY = """
        SELECT title, content, published, CAST(created_at AS DATETIME) AS dt
        FROM Post;
    """
    cursor.execute(SQL_QUERY)
    # Convert the retrieved data into a dictionary
    columns = [column[0] for column in cursor.description]
    posts = []
    for row in cursor.fetchall():
        posts.append(dict(zip(columns, row)))

    return {"data": posts}

@app.post("/posts", status_code = status.HTTP_201_CREATED)
def create_post(post: Post):

    # insert one post to SQL Server
    SQL_STATEMENT = """
        INSERT INTO Post(title,content,published) 
        OUTPUT INSERTED.id
        VALUES (?, ?, ?);
    """
    cursor.execute(SQL_STATEMENT, post.title, post.content, post.published)
    new_post_id = cursor.fetchval()
    # Retrieve the data that has just been inserted
    SQL_QUERY = """
        SELECT title, content, published, CAST(created_at AS DATETIME) AS dt
        FROM Post
        WHERE id = ?;
    """
    cursor.execute(SQL_QUERY, new_post_id)
    row = cursor.fetchone()
    # Convert the data to a dictionary to be able to send it back
    columns = [column[0] for column in cursor.description]
    new_post = dict(zip(columns, row))
    
    # Commit the transaction
    conn.commit()

    return {"data": new_post}

@app.get("/posts/latest")
def get_latest_post():
    post = my_posts[len(my_posts) - 1]
    return {"data": post}

@app.get("/posts/{id}")
def get_post(id: int, response: Response):
    # Retrieve the data that has just been inserted
    SQL_QUERY = """
        SELECT title, content, published, CAST(created_at AS DATETIME) AS dt
        FROM Post
        WHERE id = ?;
    """
    cursor.execute(SQL_QUERY, id)
    row = cursor.fetchone()

    # Raise an error if no post was found
    if not row:
         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                             detail=f"Post with id: {id} not found.")

    # Convert the data to a dictionary to be able to send it back
    columns = [column[0] for column in cursor.description]
    post = dict(zip(columns, row))

    return {"post_detail": post}

@app.delete("/posts/{id}", status_code= status.HTTP_204_NO_CONTENT)
def delete_post(id: int):
    #deleting a post
    SQL_STATEMENT = """
        DELETE Post
        OUTPUT DELETED.id, DELETED.title, DELETED.content, DELETED.published
        WHERE id = ?;
    """
    cursor.execute(SQL_STATEMENT, id)
    post = cursor.fetchone()
    print(post)
    conn.commit()
    if not post:
        raise HTTPException(status_code= status.HTTP_404_NOT_FOUND,
                            detail= f"Post with id {id} does not exist.")
    return Response(status_code=status.HTTP_204_NO_CONTENT)

@app.put("/posts/{id}")
def update_post(id: int, post: Post):
    # Update the details of a post
    SQL_STATEMENT = """
        UPDATE Post
        SET title = ?, content = ?, published = ?
        OUTPUT INSERTED.id, INSERTED.title, INSERTED.content, INSERTED.published
        WHERE id = ?;
    """
    cursor.execute(SQL_STATEMENT, post.title, post.content, post.published, id)
    row = cursor.fetchone()
    conn.commit()
    if not row:
        raise HTTPException(status_code= status.HTTP_404_NOT_FOUND,
                            detail= f"Post with id {id} does not exist.")
    columns = [column[0] for column in cursor.description]
    upd_post = dict(zip(columns, row))
    return {"data": upd_post}
